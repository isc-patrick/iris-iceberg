 I have a python library that is driven by a configuration file. Some of the objects like the SQLAlchemy Session and the logger need to be available globally so I need to initialize them first, but they require the configuration, which can be passed in at runtime, in order to initialize. The app needs the flexibility of passing in the config at runtime or loading it from default locations. What are some ways to do this?

There are several approaches you can take to handle this situation. Here are a few options, along with their pros and cons:

1. Lazy Initialization with Singleton Pattern:

   Create a singleton configuration class that loads the config when first accessed. Other global objects can then be lazily initialized when they're first needed.

   ```python
   class Config:
       _instance = None
       _initialized = False

       def __new__(cls):
           if cls._instance is None:
               cls._instance = super().__new__(cls)
           return cls._instance

       def initialize(self, config_path=None):
           if not self._initialized:
               # Load config from default locations or config_path
               self._config = load_config(config_path)
               self._initialized = True

       @property
       def config(self):
           if not self._initialized:
               self.initialize()
           return self._config

   config = Config()

   class Database:
       _instance = None

       def __new__(cls):
           if cls._instance is None:
               cls._instance = super().__new__(cls)
               cls._instance.session = create_session(config.config['database'])
           return cls._instance

   db = Database()
   ```

   Pros:
   - Flexible, allows runtime configuration
   - Lazy loading of resources

   Cons:
   - Slightly more complex
   - Potential for circular dependencies if not careful

2. Dependency Injection:

   Create a central application object that holds all the configured components and pass it around.

   ```python
   class App:
       def __init__(self, config_path=None):
           self.config = load_config(config_path)
           self.db_session = create_session(self.config['database'])
           self.logger = setup_logger(self.config['logging'])

   def some_function(app):
       app.logger.info("Doing something")
       app.db_session.query(...)

   if __name__ == "__main__":
       app = App("custom_config.yaml")
       some_function(app)
   ```

   Pros:
   - Clear dependencies
   - Easy to test with mock objects

   Cons:
   - Requires passing the app object around

3. Global Configuration Module:

   Create a global configuration module that's imported and initialized at the start of the application.

   ```python
   # config.py
   _config = None

   def init_config(config_path=None):
       global _config
       _config = load_config(config_path)

   def get_config():
       if _config is None:
           init_config()
       return _config

   # db.py
   from . import config

   _session = None

   def get_session():
       global _session
       if _session is None:
           _session = create_session(config.get_config()['database'])
       return _session

   # main.py
   from . import config, db

   if __name__ == "__main__":
       config.init_config("custom_config.yaml")
       session = db.get_session()
       # Use session...
   ```

   Pros:
   - Simple to use once set up
   - Allows for runtime configuration

   Cons:
   - Uses global state, which can make testing trickier

4. Configuration as a Context Manager:

   Use a context manager to set up and tear down the configuration and related objects.

   ```python
   class AppContext:
       def __init__(self, config_path=None):
           self.config = load_config(config_path)

       def __enter__(self):
           self.db_session = create_session(self.config['database'])
           self.logger = setup_logger(self.config['logging'])
           return self

       def __exit__(self, exc_type, exc_val, exc_tb):
           self.db_session.close()

   with AppContext("custom_config.yaml") as app:
       app.logger.info("Doing something")
       app.db_session.query(...)
   ```

   Pros:
   - Clear resource lifecycle
   - Encourages proper cleanup

   Cons:
   -